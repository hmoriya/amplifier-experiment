# Parasol 設計哲学

**作成日**: 2025-12-12
**バージョン**: V5.6

---

## 核心的な価値観

Parasolは、長年の実践経験から導き出された一つの真理に基づいています：

> **アーキテクチャの真の価値は、その保守性と変更容易性にある**

見た目の素晴らしさや技術的な洗練度ではなく、「どれだけ簡単に修正できるか」が、システムの長期的な成功を決定します。

そして、この価値を実現するために：

> **ビジネス価値からソフトウェア実装まで、すべての層が一貫してアラインメントされている**

Phase 0のビジョンから、Phase 7の実装まで、価値の一貫性（Golden Thread）が保たれることで、真のビジネス価値が実現されます。

---

## 基本原則

### グループ1: 価値と方向性（WHY）

#### 1. エンドツーエンド価値アラインメント（End-to-End Value Alignment）

**原則**: ビジネスビジョンからコードの一行まで、すべてが価値実現のために整合している

**実践**:
- Golden Thread（価値の黄金の糸）による一貫性維持
- 各フェーズ成果物の上位価値への追跡可能性
- ビジネス→システム→ソフトウェアの垂直統合
- 価値の逆流防止（下位の都合で上位価値を歪めない）

**検証メカニズム**:
- Phase間の整合性チェック（/parasol:validate）
- 価値指標の継続的モニタリング
- ステークホルダーによる価値確認
- 実装が価値を実現しているかの定期レビュー

#### 2. 価値駆動設計（Value-Driven Design）

**原則**: すべての技術的決定はビジネス価値に直結する

**実践**:
- 各ケイパビリティにROI指標を定義
- 価値の測定可能性を設計段階で組み込む
- ビジネスKPIと技術メトリクスの紐付け
- 段階的な価値実現（MVP→拡張→最適化）

**アラインメントの実現**:
- Phase 0-2: ビジネス価値の明確化（WHY）
- Phase 3: ケイパビリティへの分解（WHAT）
- Phase 4-5: サービス・ソフトウェア設計（HOW）
- Phase 6-7: 実装と運用（DELIVER）
- 各フェーズで価値の一貫性を検証

#### 3. バックキャスティング設計（Future-Back Planning）

**原則**: 3-5年後の理想状態から現在へ逆算して設計

**実践**:
- 将来ビジョンの明確化（Phase 0で定義）
- ケイパビリティ進化パスの設計
- 価値実現マイルストーンの設定
- 技術的な拡張性の確保

### グループ2: 基礎原則（WHAT）

#### 4. 保守性ファースト（Maintainability First）

**原則**: システムは作るよりも、維持・変更する期間の方が圧倒的に長い

**実践**:
- 理解しやすいコードとアーキテクチャ
- 明確なエラーメッセージとログ
- デバッグしやすい構造
- ドキュメントと実装の一致

#### 5. 変更容易性の追求（Changeability）

**原則**: ビジネスは変化し続ける。システムもそれに追従できなければならない

**実践**:
- サービスの独立性維持
- 停止・入れ替えが容易な設計
- ローカルでテスト可能
- 段階的な移行が可能

#### 6. シンプルさへの回帰（Simplicity）

**原則**: 複雑さは敵。理解できないものは修正できない

**実践**:
- APIファースト（同期通信）を基本とする
- 必要な場合のみ非同期処理（バッチ）を使用
- 過度な抽象化を避ける
- 「なぜ」が説明できる設計

### グループ3: 時間軸と進化（WHEN）

#### 7. 時間軸ケイパビリティ設計（Temporal Capability Design）

**原則**: ケイパビリティは時間とともに進化する生き物として設計

**実践**:
- 進化（Evolution）：新機能の追加
- 深化（Deepening）：既存機能の高度化
- 最適化（Optimization）：効率性の向上
- 各段階での後方互換性維持

#### 8. 段階的移行の原則（Gradual Migration）

**原則**: Big Bangリリースは失敗の温床

**実践**:
- Feature Toggleによる段階的切り替え
- カナリアデプロイメントの標準化
- ロールバック可能性の保証（5分以内）
- Dual-Writeパターンによる新旧並行稼働

### グループ4: 実装原則（HOW）

#### 9. 運用可観測性（Operational Observability）

**原則**: 見えないものは直せない

**実践**:
- ログ・メトリクス・トレースの三位一体
- 問題箇所の即座の特定可能性
- 本番環境での安全なデバッグ能力
- 構造化ログによる機械的な問題分析

#### 10. ローカル再現性（Local Reproducibility）

**原則**: 開発者のマシンで再現できない問題は解決できない

**実践**:
- 本番相当環境のローカル構築
- 外部依存の最小化とモック化
- 統合テストのローカル実行可能性
- Docker Composeによる環境標準化

#### 11. AI駆動開発（AI-Driven Development）

**原則**: 人間の創造性とAIの生産性を最大限に活用

**実践**:
- パラソルドメイン言語による仕様定義（SSOT）
- AIによる設計・実装の自動生成
- 人間による価値定義と品質保証
- 継続的な再生成による改善

**価値アラインメントの保証**:
- ドメイン言語がビジネス価値を正確に表現
- AIは価値を損なわない実装を生成
- 各層の成果物が上位の価値定義を忠実に反映
- トレーサビリティによる価値の追跡

### グループ5: 人とチーム（WHO）

#### 12. 認知負荷管理（Cognitive Load Management）

**原則**: 人間の理解力には限界がある

**実践**:
- 新人エンジニアが1週間で理解できる設計
- ドキュメントより直感的な命名とAPI
- 驚き最小の原則（Principle of Least Surprise）
- 一貫性のあるパターンの使用

#### 13. チーム持続可能性（Team Sustainability）

**原則**: システムは人が運用する。人に優しくない設計は持続しない

**実践**:
- 属人化の徹底的な排除
- オンコールの負担分散
- 深夜メンテナンスの最小化
- エラーメッセージでの次のアクション明示

---

## アンチパターンとその理由

### イベント駆動アーキテクチャの落とし穴

長年の経験から、以下の問題が繰り返し発生することが明らかになっています：

1. **停止ができない**
   - キューに溜まったメッセージの処理
   - 停止時のデータロスリスク
   - 計画的メンテナンスの困難さ

2. **ローカルテストの困難さ**
   - メッセージブローカーの準備
   - 非同期フローの再現
   - デバッグの複雑さ

3. **トランザクション制御の複雑化**
   - 分散トランザクションの管理
   - 補償トランザクションの実装
   - 一貫性保証の困難さ

4. **アップデートの困難さ**
   - メッセージフォーマットの変更
   - 互換性の維持
   - 段階的な移行の複雑さ

---

## 推奨アプローチ

### 1. Orchestration at the Edge

```
フロントエンド → API1 → 確認
            ↓
            → API2 → 確認
            ↓
            → API3 → 確認
```

**メリット**:
- 処理フローが明確で追跡しやすい
- エラー箇所が即座に特定できる
- ローカルでの再現が容易

### 2. Integration Hub Pattern

```
新システム → 統合ハブ → レガシーシステム
           ↓
           キャッシュ/変換
```

**メリット**:
- レガシー統合の複雑さを局所化
- 段階的な移行が可能
- 影響範囲が明確

### 3. 従来型バッチ処理

```
日次バッチ：
  1. データ収集
  2. 処理実行
  3. 結果確認
```

**メリット**:
- 運用実績がある
- トラブルシューティングが確立
- リカバリ手順が明確

---

## 意思決定ガイドライン

### 新しい技術・パターンを検討する際の質問

1. **理解容易性**: 新人エンジニアが1週間で理解できるか？
2. **テスト可能性**: ローカル環境で完全なテストができるか？
3. **停止可能性**: 計画的にサービスを停止できるか？
4. **デバッグ性**: 問題発生時、30分以内に原因を特定できるか？
5. **移行可能性**: 段階的な移行計画を立てられるか？

すべてに「Yes」と答えられない場合、再考が必要です。

### 運用健全性の指標

**良好な状態**:
- 平均修正時間（MTTR）< 2時間
- ローカルでの問題再現率 > 95%
- デプロイ頻度 > 1日1回以上
- ロールバック所要時間 < 5分
- オンコール対応数 < 週2件

**警告状態**:
- 特定個人への依存度 > 30%
- ドキュメント更新遅延 > 2週間
- テストカバレッジ < 70%
- 外部依存サービス > 10個

---

## 実装指針

### コード品質より保守性

```
❌ 高度に最適化されたが理解困難なコード
✅ 多少冗長でも意図が明確なコード
```

### 技術選定の基準

```
❌ 最新技術だから
✅ チームが習熟しており、運用実績があるから
```

### ドキュメントの重要性

```
❌ コードが自己文書化されている
✅ なぜその設計にしたかが文書化されている
```

---

## 想像の設計からの脱却

### ソフトウェア業界の根本的な問題

長年の経験から明らかになった、業界全体の構造的欠陥：

> **ビジネス設計なきソフトウェア設計という矛盾**

#### 現実の姿

1. **方法論の欠如**
   - ソフトウェア設計にビジネス価値を考える体系的方法論が存在しない
   - 技術的アーキテクチャは洗練されているが、ビジネスアーキテクチャは無視

2. **神話的な「ビジネスエキスパート」**
   - 実際はビジネス設計の訓練を受けていない人が多い
   - 「要件定義」という名の想像力コンテスト
   - 存在しない設計を推測で補う

3. **想像の産物**
   - 実際のビジネスオペレーションではなく、想定に基づく設計
   - 「こうあるべき」という理想と現実の乖離
   - 動くが価値を生まない「技術的に正しい」システム

#### なぜこの問題が生まれたか

**歴史的経緯**:
- ソフトウェアは計算機科学から生まれ、ビジネススクールからではない
- エンジニアリングの美学が、ビジネス価値より優先された
- 「ビジネス側」と「技術側」という人工的な分断

**構造的要因**:
```
従来のアプローチ：
ビジネス（謎） → 翻訳（推測） → 技術（明確）
                ↑ ここで価値が失われる
```

### Parasolの根本的転換

#### ビジネスアーキテクチャ＝ソフトウェアアーキテクチャ

```
新しいアプローチ：
価値の流れ（Value Stream）を発見
    ↓
ビジネスオペレーションを分析
    ↓
技術設計に直接反映
    ↓
価値を実現するコード
```

#### 具体的な実践

1. **価値ストリーム駆動設計**
   - 「何が価値を生むか」から始める
   - 技術選択は価値実現の手段に過ぎない

2. **オペレーション中心思考**
   - 実際のビジネスプロセスが設計の基礎
   - 想像ではなく、観察と分析

3. **検証可能な価値**
   - ビジネスメトリクスで成功を測定
   - 技術メトリクスは二次的

#### ソフトウェアエンジニアの新しい役割

**従来**: 技術の専門家
**Parasol**: ビジネスアーキテクト兼技術実装者

これは技術力の放棄ではない。ビジネス価値に根ざした技術力の発揮である。

#### 検証の問い

すべての設計判断に対して：
1. これはどの価値ストリームに寄与するか？
2. どのビジネスオペレーションを可能にするか？
3. 測定可能なビジネス価値は何か？

答えられない場合、それは**想像の設計**である。

### DDDとの根本的な違い

#### DDDの理想と現実のギャップ

**Domain-Driven Design（DDD）**は、ドメインエキスパートとの協働を前提とした優れた設計手法である。しかし、長年の実践から明らかになった問題：

1. **ドメインエキスパートの神話**
   - 理想：ビジネス全体を理解し、明確に説明できる専門家
   - 現実：部分的な視点、矛盾する意見、時間の制約

2. **方法論の限界**
   ```
   Event Storming → ドメインエキスパートが必須 → いない場合は推測
   Domain Storytelling → 正確な物語が必要 → 主観的な解釈
   Example Mapping → 完全な例が必要 → エッジケースの欠落
   ```

3. **失敗パターン**
   - モデルとコードの乖離
   - 技術駆動の境界設定
   - 過度な抽象化

#### Parasolのアプローチ

**ドメインエキスパート依存からの解放**:

```
DDD：    エキスパート → ワークショップ → モデル → 実装
         ↑ ボトルネック（存在しない/不完全）

Parasol： 公開情報 → 価値分析 → ケイパビリティ → 実装
         ↑ AI駆動で体系化
```

**具体的な違い**:

| 側面 | DDD | Parasol |
|------|-----|---------|
| 知識源 | 人間のエキスパート | 観察可能な価値 |
| 境界設定 | イベントから発見 | 価値ストリームから設計 |
| 用語定義 | 議論から創発 | 体系的分析から導出 |
| スケール | ワークショップ依存 | 体系的に適用可能 |

**重要な洞察**:
> Parasolはドメインエキスパート問題を解決しようとしない - その依存を完全に排除する

#### DDDのボトムアップ性とその限界

**なぜDDDはボトムアップなのか**:

```
ドメインエキスパートの会話
    ↓
イベント/エンティティの発見
    ↓
集約の形成
    ↓
Bounded Contextの創発
    ↓
コンテキストマップの作成
```

この手法は開発者の思考パターン（具体→抽象）と一致するため自然に感じられる。

**断片化の問題**:

| エキスパート | 視点 | 見えない部分 |
|-------------|------|-------------|
| 営業 | 顧客、注文、価格設定 | 在庫、財務との連携 |
| 在庫 | 在庫レベル、倉庫、サプライヤー | 営業、財務との統合 |
| 財務 | 取引、会計、コンプライアンス | 営業、在庫の実態 |

結果：各Bounded Contextは孤島となり、統合は後付け。

**Parasolのトップダウン性**:

```
組織の目的
    ↓
価値ストリーム（価値の流れ方）
    ↓
ケイパビリティ（価値を可能にするもの）
    ↓
技術的分解
```

**根本的な違い**:

| 側面 | DDD（ボトムアップ） | Parasol（トップダウン） |
|------|-------------------|---------------------|
| 出発点 | 専門家の部分的知識 | 組織全体の価値創造 |
| 統合 | 創発的（偶然に頼る） | 設計的（意図的） |
| 最適化 | 局所的（各コンテキスト） | 全体的（価値フロー） |
| 変更対応 | 予測困難な波及 | 価値ラインに沿った変更 |

**「木を見て森を見ず」問題**:

```
DDD: 「Order集約は完璧にモデリングできました！」
ビジネス: 「でも注文から入金まで5日かかるのはなぜ？」
DDD: 「それは3つのBounded Contextにまたがるので...」

Parasol: 「注文-入金価値ストリームをマッピングしました」
ビジネス: 「どのくらいかかる？」
Parasol: 「最大2日です - そのフローで設計しました」
```

**認知的なマッチング**:

開発者の思考パターン（ボトムアップ）:
- コードは関数ごとに書く
- システムはコンポーネントごとに構築
- 理解は具体から一般へ

ビジネスの動作パターン（トップダウン）:
- 戦略が戦術を駆動
- ゴールが活動を駆動
- 価値が投資を駆動

**Parasolの橋渡し**: トップダウンのフレームワークを提供しながら、ボトムアップの実装タスクに分解することで、開発者にとって自然な形に落とし込む。

---

## まとめ

Parasolは「普通」を大切にします。特別な知識や高度なスキルがなくても、誰でも理解し、修正し、運用できるシステムこそが、長期的に価値を提供し続けることができるのです。

複雑さに立ち向かう最良の方法は、そもそも複雑にしないことです。

そして最も重要なのは、**実在するビジネス価値のために、実在するシステムを作る**ことです。想像の要件のために想像のアーキテクチャを作る時代は終わりました。

> **"Simplicity is the ultimate sophistication"** - Leonardo da Vinci

この哲学は、すべてのParasolコマンドとパターンの根底にあり、私たちの設計判断を導く北極星となります。

---

## 関連ドキュメント

- **哲学の解説**: [PHILOSOPHY-EXPLAINED.md](./PHILOSOPHY-EXPLAINED.md) - 「哲学とは何か」の詳細な説明
- **DDDとの比較分析**: [DDD-VS-PARASOL-ANALYSIS.md](./DDD-VS-PARASOL-ANALYSIS.md) - DDDとParasolのビジネス分析手法の詳細比較
- **実装ガイド**: [IMPLEMENTATION-GUIDE.md](./IMPLEMENTATION-GUIDE.md) - この哲学を実装レベルで実践するための具体的なコード例とパターン集