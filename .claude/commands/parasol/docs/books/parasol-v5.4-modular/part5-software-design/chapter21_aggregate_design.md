# Chapter 21: 集約設計 — トランザクション境界の芸術

## 2億円が消えた日

2019年、日本のある地方銀行で起きた事件は、技術者たちを震撼させました。朝9時、定期振込処理が開始された瞬間、複数の口座から同じ金額が二重に引き落とされ始めたのです。

「おかしい、同じトランザクションIDが複数回処理されている！」エンジニアの田中は画面を食い入るように見つめました。振込システムは、送金元口座の残高確認、引き落とし、送金先への入金という一連の処理を実行していました。しかし、マイクロサービス化されたシステムでは、各処理が独立したサービスとして動作していたため、途中で一部のサービスがタイムアウトすると、リトライ機構が「部分的に成功した」トランザクションを最初から再実行していたのです。

45分後、システムは緊急停止されました。被害総額：2億3千万円。影響を受けた口座：1,247件。

調査の結果、根本原因は明確でした。「トランザクション境界」が適切に設計されていなかったのです。口座という最も重要なビジネスエンティティの一貫性を、複数のサービスにまたがって維持しようとした結果、分散トランザクションの罠に落ちていました。

この事件は、21世紀のシステム設計における根本的な問いを投げかけます：**どこまでを一つの原子的な単位として扱うべきか？**

## なぜこの問題が重要なのか

### ビジネスインパクト（エグゼクティブ向け）
- **信頼の喪失**: 金融システムでの不整合は顧客の信頼を一瞬で破壊
- **規制リスク**: データ整合性違反は重大な法的責任を招く
- **機会損失**: システム停止による取引機会の喪失（上記事例では3時間の営業停止）

### 技術的課題（アーキテクト向け）
- **分散システムの限界**: ネットワーク分断、部分的失敗への対処
- **パフォーマンスvs一貫性**: 大きすぎる境界は性能を殺し、小さすぎる境界は整合性を失う
- **並行性の管理**: 複数ユーザーの同時アクセスとデータ競合

### 実装の困難さ（開発者向け）
- **ORマッピングの複雑性**: オブジェクトグラフとDB設計のミスマッチ
- **テストの難しさ**: トランザクション境界をまたぐテストケースの作成
- **デバッグの困難**: 分散環境での問題の再現と原因特定

## 集約：一貫性の守護者

### 集約とは何か

集約（Aggregate）は、Eric EvansがDomain-Driven Designで提唱した、**一貫性境界を明示的に定義するパターン**です。データとそれを操作するビジネスルールを一つのまとまりとして扱い、外部からの変更を制御された入口（集約ルート）経由でのみ許可します。

銀行口座の例で考えてみましょう。口座には残高、取引履歴、利用限度額などの情報があります。これらは常に整合性を保つ必要があります：

```
口座集約
├─ 口座（集約ルート）
│   ├─ 口座番号
│   ├─ 現在残高
│   └─ 状態（アクティブ/凍結）
├─ 取引履歴（エンティティ）
│   ├─ 取引ID
│   ├─ 金額
│   └─ 日時
└─ 利用限度設定（値オブジェクト）
    ├─ 1日あたり限度額
    └─ 1回あたり限度額
```

### 集約ルートの役割

集約ルートは、集約内の一貫性を保証する**唯一の入口**です。城門の守衛のように、すべての変更要求を検査し、ビジネスルールに違反しないかを確認します：

```typescript
class BankAccount {  // 集約ルート
  withdraw(amount: Money): TransactionResult {
    if (this.balance.isLessThan(amount)) {
      return TransactionResult.insufficientFunds();
    }
    if (this.exceedsDailyLimit(amount)) {
      return TransactionResult.limitExceeded();
    }
    // すべてのルールをパスした場合のみ実行
    this.balance = this.balance.subtract(amount);
    this.recordTransaction(amount, TransactionType.WITHDRAWAL);
    return TransactionResult.success();
  }
}
```

### 集約設計の4つの基本ルール

1. **真の不変条件を守る**: 集約内では、ビジネスルールが常に満たされる
2. **小さく保つ**: パフォーマンスと並行性のため、必要最小限のサイズに
3. **ID参照を使う**: 他の集約への参照は、オブジェクト参照ではなくID経由で
4. **結果整合性を受け入れる**: 集約間の整合性は、即座でなく最終的に達成

### 境界を越えた協調：結果整合性

完璧な即時一貫性を求めると、システム全体が一つの巨大なトランザクションになってしまいます。代わりに、集約間では**結果整合性（Eventual Consistency）**を採用します：

```
時刻T1: 注文集約が「注文確定」イベントを発行
時刻T2: 在庫集約がイベントを受信し、在庫を減らす
時刻T3: 配送集約がイベントを受信し、配送準備を開始

T1からT3の間、システム全体は一時的に不整合な状態にありますが、
最終的にはすべての集約が整合性のある状態に収束します。
```

## 実践例：ECサイトの在庫管理システム

### 初期状態：密結合の悪夢

ある中規模ECサイトでは、すべてが一つの巨大な「商品」テーブルに詰め込まれていました：

- 商品基本情報（名前、説明、画像）
- 在庫情報（数量、倉庫別配置）
- 価格情報（定価、セール価格、期間）
- レビュー情報（評価、コメント）

結果は悲惨でした。商品ページを表示するだけで巨大なデータをロードし、在庫更新時には頻繁にデッドロックが発生していました。

### 課題認識：何が間違っていたか

分析の結果、異なるライフサイクルと更新頻度を持つデータが混在していることが判明しました：
- 商品基本情報：めったに変更されない
- 在庫情報：秒単位で変化する
- 価格情報：日次でバッチ更新
- レビュー：ユーザーが追加するたびに増加

### 解決適用：集約への分解

チームは4つの独立した集約に分解しました：

```typescript
// 商品カタログ集約（変更頻度：低）
class Product {
  constructor(
    private id: ProductId,
    private name: string,
    private description: string
  ) {}
}

// 在庫集約（変更頻度：高）
class Inventory {
  constructor(
    private productId: ProductId,
    private quantity: number
  ) {}
  
  reserve(amount: number): ReservationResult {
    if (this.quantity >= amount) {
      this.quantity -= amount;
      return ReservationResult.success();
    }
    return ReservationResult.insufficientStock();
  }
}
```

### 結果評価：劇的な改善

分解後の効果は顕著でした：
- **スループット**: 在庫更新が10倍高速化（ロック競合の減少）
- **可用性**: 商品情報表示は在庫システム障害の影響を受けなくなった
- **保守性**: 各チームが独立して自分の集約を改善できるように

## いつ・どのように使うべきか

### 適用タイミング

集約設計が特に有効な場面：
- 複数のエンティティ間に守るべきビジネスルールがある
- システムに高い並行性が求められる
- マイクロサービス化を検討している
- トランザクション競合が頻発している

### 成功の条件

- **明確な境界**: ビジネス的に意味のある単位で区切る
- **適切なサイズ**: 「注文と注文明細」程度の粒度を目指す
- **一貫した言語**: ビジネス用語と技術用語の統一

### よくある落とし穴

1. **巨大集約症候群**: 「念のため」で境界を広げすぎる
   - 症状：パフォーマンス劣化、並行性の低下
   - 対策：本当に同時に変更が必要なものだけを含める

2. **細分化の罠**: 集約を小さくしすぎる
   - 症状：ビジネスルールが複数集約にまたがる
   - 対策：不変条件を基準に境界を見直す

3. **即時一貫性への固執**: すべてを同期的に処理しようとする
   - 症状：分散トランザクションの多用
   - 対策：ビジネス要件を再確認し、結果整合性を検討

## 他の手法との組み合わせ

### マイクロサービスとの親和性
集約境界は自然なサービス境界となります。各マイクロサービスが1つまたは少数の集約を管理することで、サービス間の結合度を下げられます。

### イベントソーシングへの道
集約から発生するドメインイベントは、次章で扱うCQRSとイベントソーシングの基盤となります。集約の状態変更を イベントとして記録することで、監査証跡と時系列分析が可能になります。

### Sagaパターンでの調整
複数の集約にまたがる長時間実行プロセスは、Sagaパターンで調整します。各集約は自律的に動作しながら、全体として一つのビジネスプロセスを完成させます。

## 集約設計チェックリスト

設計完了前に確認すべき項目：

- [ ] 各集約は単一のトランザクションで更新可能か
- [ ] 集約境界はビジネス的に意味があるか  
- [ ] 不変条件は集約内で完結しているか
- [ ] ID参照で集約間を疎結合にしているか
- [ ] 集約のサイズは適切か（目安：エンティティ数3-5個）
- [ ] 結果整合性で十分な箇所を特定したか

## 次章への展望

集約によって守られた一貫性境界は、システムの信頼性の基盤となります。次章では、この集約を起点として、読み取りと書き込みを分離するCQRSパターンと、すべての変更を イベントとして記録するイベントソーシングについて探求します。集約が「現在の状態」を守るのに対し、イベントソーシングは「どのように現在に至ったか」の完全な履歴を提供します。

2億円が消えた事件から学んだ教訓は明確です：**境界を正しく引くことが、信頼できるシステムの第一歩**なのです。

---

*完全な実装例とパターンカタログは付録21.1-21.3を参照してください。*