# 第4章　V5とDDDの関係性 ― 巨人の肩に乗って更に高く

## はじめに：DDDへの敬意と、その先へ

ある勉強会での出来事です。

「DDDって、結局何なんですか？」

若手エンジニアの質問に、ベテランアーキテクトは少し困った顔をしました。

「それは... ドメインを中心に考えて、ビジネスの複雑さをモデルで表現して...」

説明は続きますが、質問者の顔は曇ったままです。

「で、具体的にどうやるんですか？」

この瞬間、部屋の空気が少し重くなりました。DDDを実践してきた人なら、この気まずさが分かるはずです。

DDDは素晴らしい。それは間違いありません。エリック・エヴァンスが提唱したこの設計思想は、ソフトウェア設計に革命をもたらしました。でも同時に、多くの人が「分かったような、分からないような」もやもやを抱えているのも事実です。

本章では、DDDの価値を最大限に認めつつ、Parasol V5がどのようにDDDを「使いやすく」し、さらに発展させるかを探ります。

これは「DDDを否定する」話ではありません。むしろ「DDDの理想を、より多くの人が実現できるようにする」話です。巨人の肩に乗って、さらに遠くを見渡すように。

## DDDの光と影

### DDDがもたらした革命

2003年、エリック・エヴァンスの「Domain-Driven Design」が出版されました。この本は、ソフトウェア設計の歴史における分水嶺となりました。

DDDがもたらした最大の貢献は何でしょうか？

それは、**「ビジネスとシステムは一体である」**という思想です。

それまでの開発では、ビジネス側が「要件」を投げ、技術側がそれを「実装」する—— まるで翻訳作業のような関係でした。でもDDDは違います。ビジネスエキスパートと開発者が、同じ言語（ユビキタス言語）で語り合い、共にモデルを作り上げていく。

これは革命的でした。

### DDDの主要概念と、その輝き

DDDの主要概念を振り返ってみましょう：

**ユビキタス言語**
```
営業：「顧客に請求書を送る」
開発：「CustomerにInvoiceをsendする」
→ 同じ言葉で、同じ概念を表現
```

**境界づけられたコンテキスト（Bounded Context）**
```
販売コンテキスト：
  「顧客」= 購入者、クレジットカード情報を持つ

サポートコンテキスト：
  「顧客」= 問い合わせ者、サポート履歴を持つ

→ 同じ「顧客」でも、文脈によって意味が変わることを認める
```

**集約（Aggregate）**
```
注文集約 {
  注文（ルート）
  注文明細
  配送先
}
→ 一貫性を保つべき単位を明確に
```

これらの概念は、複雑なビジネスロジックを整理する強力なツールとなりました。

### しかし、なぜDDDは難しいのか

でも、正直に言いましょう。DDDは難しい。

なぜでしょうか？

#### 1. 抽象度の高さ

DDDの概念は、非常に抽象的です。「境界づけられたコンテキスト」と言われても、具体的にどう線を引けばいいのか。「ユビキタス言語」といっても、誰がどう決めるのか。

ある開発者の言葉が印象的です：

「DDDの本を3回読みました。理屈は分かります。でも月曜日の朝、何から始めればいいかは分からないんです」

#### 2. 実装とのギャップ

美しいドメインモデルを描いても、それをコードに落とす段階で多くの妥協が生まれます。

```java
// 理想のモデル
class Order {
    void placeOrder() {
        // ビジネスロジック
    }
}

// 現実のコード
class OrderService {
    @Transactional
    public OrderDTO placeOrder(OrderRequest request) {
        // トランザクション管理
        // バリデーション
        // 永続化
        // イベント発行
        // DTO変換
        // エラーハンドリング
        // ... 技術的関心事で埋もれるビジネスロジック
    }
}
```

#### 3. 文化的障壁

DDDは「ビジネスと開発の協働」を前提としています。でも、多くの組織では、まだその文化がありません。

「ドメインエキスパート？うちの営業は忙しくて、そんな時間ないよ」
「ユビキタス言語を作る？それって誰の仕事？」

### 戦術的パターンの罠

そして、多くのチームが陥る罠があります。**戦術的パターンへの過度な執着**です。

「エンティティとは」「値オブジェクトとは」「リポジトリとは」—— パターンの定義と実装に多大な時間を費やし、本来の目的である「ビジネス価値の実現」を見失ってしまう。

ある企業では、「完璧なDDD実装」を目指して1年かけてフレームワークを作りました。結果？ビジネス側は待ちきれず、別の簡易システムを作ってしまいました。

## V5の立ち位置：DDDを「使える」ものに

### CL構造とDDDの明確なマッピング

Parasol V5は、DDDの概念を**CL1/CL2/CL3の3段階構造**で段階的に具体化します。

**CL構造とDDD概念の対応表**

| Parasol CL | DDDの対応概念 | 役割 |
|------------|-------------|------|
| CL1（活動領域識別） | Strategic Design初期検討 | 傾向的分類（参考のみ） |
| CL2（ケイパビリティ設計） | Core Domain識別 | 正式分類（投資判断の根拠） |
| CL3（オペレーション定義） | 業務オペレーション（BizOp） | Phase 4-5でのBC境界確定への入力 |
| Phase 4-5 | **Bounded Context** | 実装単位の定義 |

**重要な設計原則**

```
┌─────────────────────────────────────────────────────────────┐
│ CL1の分類はCL2に継承されない                                 │
│ ─────────────────────────────────────────────────────────── │
│ CL1: 傾向的分類（参考情報のみ）                               │
│ CL2: 独立した再評価（投資判断の正式な根拠）                   │
│ CL3: 分類なし（網羅性を重視、業務オペレーションを定義）       │
│ Phase 4-5: CL3を基にBounded Contextの境界確定と実装設計      │
└─────────────────────────────────────────────────────────────┘
```

**なぜこの構造が重要か？**

DDDのStrategic Designでは、「どこに投資するか」の判断が最も重要です。しかし、初期の仮説（CL1）に縛られると、本当のCore Domainを見落とす危険があります。

V5では：
1. **CL1**で全体を俯瞰（仮説形成）
2. **CL2**で白紙から再評価（投資判断）
3. **CL3**で業務オペレーションを定義（ビジネス観点の網羅）
4. **Phase 4-5**でBounded Contextの境界確定と実装設計

この段階的アプローチにより、DDDの「正しい場所に正しく投資する」という理想を確実に実現できます。

**Phase 4-5でパラソルドメイン言語へ**

Phase 4-5で定義されたBounded Contextには、**パラソルドメイン言語**が適用されます。

```
CL3（業務オペレーション）
  │ Phase 4-5で境界確定
  ▼
Bounded Context
  │
  ├─ Aggregate（集約）
  ├─ Value Object（値オブジェクト）
  ├─ Domain Event（ドメインイベント）
  ├─ Domain Service（ドメインサービス）
  └─ Repository（リポジトリ）
  │
  ▼
UI / API / DB（実装）
```

パラソルドメイン言語は、DDDの戦術的パターンを**アーキテクチャ非依存**で定義し、そこからUI/API/DBのコードを生成します。

### 2段階ZIGZAGモデル ― 価値から実装への道筋

Parasol V5は「2段階ZIGZAGモデル」で価値から実装まで体系的に分解します。これはDDDの問題空間（Problem Space）と解決空間（Solution Space）の考え方を発展させたものです。

```
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
【第1段階】価値のZIGZAG（Phase 2）
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

  VL1 ────→ VL2 ────→ VL3 ────→ VMS ────→ VS
 (WHAT)    (HOW)     (WHAT')   (HOW')   (WHAT'')
 最上位価値  ↓構造化   構造化価値  ↓マイル定義  マイル成果

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
【第2段階】ビジネスと設計のZIGZAG（Phase 3-6）
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

┌─────────────────────────────────────────────────────────────┐
│ Problem Space（問題領域）                                    │
│  CL1(WHAT) ──→ CL2(HOW) ──→ CL3(WHAT')                     │
│  活動領域       ドメイン分類    業務オペレーション             │
└─────────────────────────────────────────────────────────────┘
                    ↓ 問題→解決 変換（DDDマッピング）
┌─────────────────────────────────────────────────────────────┐
│ Solution Space（解決領域）                                   │
│  BC(WHAT) ───→ Service(HOW) ──→ 実装(WHAT')                │
│  境界Ctx        サービス設計      コード                      │
└─────────────────────────────────────────────────────────────┘
```

**第1段階**では「何を実現するか（価値）」を明確にします。抽象的な最上位価値（VL1）から、行動可能な価値単位（VL3）へと分解し、マイルストーン（VMS）を設定して、顧客の状態変化（VS0-VS7）として可視化します。

**第2段階**では「どう実現するか」を設計します。DDDの問題空間（CL1→CL2→CL3）で業務を理解し、解決空間（BC→Service→実装）で技術を設計します。

このZIGZAGパターンの本質は「WHATで行き詰まったらHOWへ視座転換」することで、暗黙知を顕在化させる創発的分解にあります。

> 📚 **詳細参照**: 価値駆動ZIGZAGプロセスの詳細については [ZIGZAGプロセス](../../philosophy/zigzag-process.md) を参照してください。

### DDDの理想を、段階的に実現可能に

Parasol V5は、DDDを否定しません。むしろ、DDDの理想を**段階的に、確実に**実現する道筋を提供します。

建築に例えるなら：
- DDD：「理想の家の完成図」を示す
- V5：「基礎から順番に建てる具体的な工程」を示す

V5の8フェーズは、DDDの概念を自然に、段階的に導入できるよう設計されています。

### Phase 2で生まれるユビキタス言語

V5のPhase 2「価値分析・価値設計」では、価値ストリームを定義します。この過程で、自然にユビキタス言語が生まれます。

**従来のDDD**：
「まず、ユビキタス言語を定義しましょう」
→ 何から始める？誰が決める？

**V5のアプローチ**：

> **価値ストリーム：受注履行**
> - トリガー：顧客が商品を購入する
> - アウトカム：商品が顧客に届く
>
> **この過程で自然に言語が定まる（主要用語）：**
> - 受注：顧客の購入意思表示
> - 在庫引当：商品を顧客のために確保
> - 出荷指示：倉庫への配送命令

価値を定義する過程で、ビジネスと開発が自然に同じ言葉を使い始めます。

### Phase 3で見えてくる業務オペレーション

Phase 3「ケイパビリティ分解」では、価値を実現するために必要な能力を洗い出します。この時、業務オペレーション（CL3）を網羅的に定義し、Phase 4-5でのBounded Context境界確定の入力とします。

> **ケイパビリティ：在庫管理**
> - 目的：正確な在庫数を維持し、適切な引当を行う
> - 業務オペレーション（CL3）：
>   - 在庫数管理オペレーション
>   - 引当オペレーション
>   - 棚卸オペレーション
> - Phase 4-5でBC境界を確定：在庫コンテキスト

「どこに境界を引くか」という難しい問題を、「どんな業務オペレーションが必要か」という具体的な問いに変換し、Phase 4-5で実装境界を確定します。

### 実装への明確な道筋

V5は、モデルから実装への道筋も明確にします。

**Phase 4-5：技術設計**

> **サービス設計**
> - コンテキスト：在庫コンテキスト
>
> **集約**
> | 集約名 | ルート | エンティティ | 値オブジェクト |
> |--------|--------|--------------|----------------|
> | 在庫 | 商品在庫 | 在庫履歴 | 在庫数, 引当情報 |
>
> **API設計**
> | 種別 | 操作 | エンドポイント |
> |------|------|----------------|
> | コマンド | 在庫追加 | POST /inventory/add |
> | コマンド | 在庫引当 | POST /inventory/reserve |
> | クエリ | 在庫照会 | GET /inventory/{productId} |

抽象的なモデルが、具体的なAPIとサービス設計に自然に変換されます。

## 具体例で理解する：ECサイトの受注処理

### 従来のDDDアプローチ

まず、従来のDDDアプローチを見てみましょう。

チームは、エヴァンスの本を片手に議論を始めます：

「受注って、エンティティ？それとも集約ルート？」
「顧客は別のBounded Context？それとも同じ？」
「在庫って値オブジェクト？」

議論は白熱しますが、なかなか結論が出ません。そして、完璧なモデルを求めて、時間だけが過ぎていきます。

### V5アプローチ：価値から始める

V5では、まず「なぜ受注処理が必要か」から始めます。

**Phase 2：価値分析**

> **価値ストリーム：オンライン受注**
>
> **ビジネス価値：**
> - 売上獲得：月間1億円
> - 顧客満足：24時間いつでも購入可能
> - 業務効率：自動化により人件費削減
>
> **プロセスフロー：**
> 1. 顧客が商品を選ぶ
> 2. カートに入れる
> 3. 注文を確定する
> 4. 在庫を引き当てる
> 5. 決済を処理する
> 6. 出荷指示を出す

この段階で、チームはビジネス価値を共有し、プロセスの全体像を掴みます。

**Phase 3：ケイパビリティ分解**

> **ケイパビリティ一覧**
>
> | ケイパビリティ | 責務 |
> |--------------|------|
> | 受注管理 | 注文の受付と管理、注文ステータスの追跡 |
> | 在庫管理 | 在庫数の管理、在庫の引当と解放 |
> | 決済処理 | 支払い処理、返金処理 |

ケイパビリティが、自然にBounded Contextの候補になります。

### DDDパターンの自然な適用

V5の構造に従って進めると、DDDのパターンが自然に適用されます。

**集約の発見**

Phase 3で見つけた「まとまり」が集約になる：

> **注文集約（Order Aggregate）**
>
> **不変条件：**
> - 注文金額は明細の合計と一致する
> - キャンセルは出荷前のみ可能
>
> **構成要素：**
> | 種別 | 名前 |
> |------|------|
> | ルート | Order |
> | エンティティ | OrderLine（注文明細） |
> | 値オブジェクト | Money（金額）、Address（配送先） |

**イベントの識別**

Phase 2の流れから、自然にイベントが見える：

> **ドメインイベント：**
> - 注文受付完了
> - 在庫引当完了
> - 決済承認
> - 出荷指示済み

### 実装への落とし込み

そして、Claude Codeがサポートしながら、実装に落とし込みます：

```python
# V5の設計から自動生成されるコード構造
class OrderAggregate:
    """受注集約 - V5 Phase 3で識別"""
    
    def __init__(self, order_id: OrderId):
        self.order_id = order_id
        self.order_lines: List[OrderLine] = []
        self.status = OrderStatus.DRAFT
        self.events: List[DomainEvent] = []
    
    def place_order(self) -> None:
        """注文確定 - 不変条件を守りながら状態遷移"""
        if self.status != OrderStatus.DRAFT:
            raise InvalidOperationError("下書き以外は確定できません")
            
        self._validate_order_total()
        self.status = OrderStatus.PLACED
        self.events.append(OrderPlacedEvent(self.order_id))
    
    def _validate_order_total(self) -> None:
        """不変条件：注文金額の整合性"""
        # V5で定義した不変条件の実装
```

コードは、V5の設計を忠実に反映し、かつDDDのベストプラクティスに従っています。

## V5がDDDを超える瞬間

### 1. 価値の定量化

DDDは「ビジネス価値」を語りますが、定量化までは求めません。V5は違います。

> **価値メトリクス：受注処理の高速化**
>
> | 項目 | 現状 | 目標 |
> |------|------|------|
> | 処理時間 | 平均3分/注文 | 平均30秒/注文 |
>
> **インパクト：**
> - 顧客満足度：4.2 → 4.8
> - カート放棄率：25% → 10%
> - 売上増加：年間3000万円

すべての設計判断が、具体的な数値に基づいて行われます。

### 2. 変更への対応力

DDDは「深いモデル」を重視しますが、変更への対応は開発者の力量に委ねられます。V5は、変更を前提とした設計を行います。

> **ケイパビリティ進化：在庫管理（v1.0）**
>
> **将来の検討事項：**
> - 複数倉庫対応
> - リアルタイム在庫同期
> - AI需要予測
>
> **拡張ポイント（将来の拡張ポイントを明示）：**
> - 在庫計算ロジックのプラグイン化
> - 外部倉庫システムとの連携API

### 3. 段階的な洗練

DDDは「正しいモデル」を求めますが、V5は「段階的な改善」を前提とします。

> **モデル成熟度**
>
> | フェーズ | モデル | 適用範囲 | トリガー |
> |----------|--------|----------|----------|
> | Phase 1 | シンプル（単一倉庫、即時引当） | MVP、月商1000万円まで | - |
> | Phase 2 | 拡張（複数倉庫、予約引当） | - | 月商5000万円超、在庫切れクレーム増加 |
> | Phase 3 | 高度（AI予測、動的配分） | - | グローバル展開、在庫回転率の最適化要求 |

「今」必要十分なモデルから始め、ビジネスの成長に合わせて洗練させていきます。

## Claude Codeとの協働によるDDD実践

### AIが変えるモデリング

Claude Codeは、DDDの実践を劇的に変えます。

**従来の苦労**：
「このビジネスルール、どの集約に入れるべき？」
→ 延々と議論

**Claude Codeとの対話**：
```
あなた：在庫引当のルールは、注文集約と在庫集約、どちらに入れるべきでしょうか？

Claude：在庫引当のルールを分析しましょう。

責任の観点：
- 注文：「何を」「いくつ」引き当てるか
- 在庫：「引当可能か」「どう引き当てるか」

凝集性の観点：
- 引当ロジックが変わっても注文は変わらない
- 引当方式は在庫管理の関心事

推奨：在庫集約に配置
理由：引当は在庫の一貫性に関わる中核的な責任

実装例：
[具体的なコード例を提示]
```

AIが、DDDの原則に基づいて、具体的な判断をサポートします。

### パターンの適切な適用

Claude Codeは、パターンの「適切な」適用も支援します。

```
あなた：ユーザー認証情報は値オブジェクトにすべきですか？

Claude：ユーザー認証情報の特性を確認しましょう。

値オブジェクトの条件：
1. 不変性 → パスワード変更があるので✗
2. 概念的な全体性 → 認証情報は独立した概念○
3. 交換可能性 → 更新はあるが交換ではない△

推奨：エンティティとして扱う
理由：
- ライフサイクルを持つ（作成→更新→無効化）
- 監査証跡が必要
- 一意性が重要（同一ユーザーの認証情報）

ただし、パスワードハッシュは値オブジェクトに：
[実装例]
```

### 継続的なモデル改善

そして、Claude Codeは継続的な改善も支援します。

```
定期レビュー：
「現在のモデルで3ヶ月運用しました。以下の課題が見えています：」
- 注文変更の頻度が想定より高い
- 在庫の部分引当ニーズが発生
- 配送日指定の要望増加

Claude：モデルの進化を提案します。

1. 注文変更への対応
   - イベントソーシングの部分適用
   - 変更履歴の永続化

2. 在庫の部分引当
   - 引当単位の細分化
   - 引当状態の詳細化

3. 配送オプションの拡張
   - 配送ポリシーの外部化
   - ストラテジーパターンの適用

[各提案の詳細設計]
```

## V5×DDD：新しい設計プロセス

### 統合されたプロセス

V5とDDDを組み合わせた、新しい設計プロセスを整理しましょう。

> **統合プロセス**
>
> | ステージ | V5フェーズ | DDDアクティビティ |
> |----------|------------|-------------------|
> | 基盤構築 | Phase 0, 1 | ドメインエキスパートの特定、初期の語彙収集 |
> | モデリング | Phase 2, 3 | ユビキタス言語の確立、Bounded Contextの識別、コアドメインの特定 |
> | 設計 | Phase 4, 5 | 集約の設計、ドメインサービスの定義、リポジトリインターフェース |
> | 実装 | Phase 6, 7 | 戦術的パターンの実装、イベント駆動の統合 |

各段階で、V5の構造がDDDの実践をガイドします。

### 成功のためのプラクティス

**1. 価値駆動のユビキタス言語**

単なる用語集でなく、価値と紐づける：

> **用語定義：プレミアム会員**
>
> | 観点 | 内容 |
> |------|------|
> | ビジネス上の意味 | 年間10万円以上購入する優良顧客 |
> | システム表現 | `Customer.tier == "PREMIUM"` |
>
> **価値へのインパクト：**
> - LTV：通常会員の3.5倍
> - 解約率：5%（通常会員は20%）

**2. 段階的なContext分割**

最初は大きく、徐々に分割：

> **初期コンテキスト：**
> - 販売システム（すべて含む）
>
> **成熟期コンテキスト：**
> - 商品カタログContext
> - 受注管理Context
> - 在庫管理Context
> - 配送管理Context
> - 顧客管理Context
>
> **分割トリガー：**
> - チーム分割
> - パフォーマンス要求
> - 独立したデプロイ要求

**3. Living Documentation**

V5の設計書 = 生きたドキュメント：

> **ドキュメント設定**
>
> | 項目 | 内容 |
> |------|------|
> | フォーマット | YAML/Markdown |
> | 配置場所 | リポジトリ内 |
> | 更新方法 | プルリクエストで更新 |
> | 検証 | Claude Codeが整合性チェック |
>
> **メリット：**
> - コードと設計の乖離を防ぐ
> - 新メンバーの理解が早い
> - AIが常に最新情報を参照

## まとめ：DDDの理想を、みんなのものに

### V5が実現すること

本章で見てきたように、Parasol V5は：

1. **DDDの理想を段階的に実現可能にする**
   - 抽象的な概念を、具体的なステップに分解
   - 各段階で明確な成果物を定義

2. **価値を中心にDDDを再構築する**
   - すべての設計判断を価値に紐づけ
   - 定量的な評価を可能に

3. **AIの力でDDDの実践ハードルを下げる**
   - 難しい判断をAIがサポート
   - パターンの適切な適用を支援

### DDDは死んでいない、進化している

DDDの本質—「ビジネスとシステムの一体化」—は、今も変わらず重要です。むしろ、ビジネス変化の速い現代こそ、その重要性は増しています。

V5は、DDDを否定するのではなく、**より多くの人が、より確実に、DDDの恩恵を受けられるようにする**フレームワークです。

エヴァンスが示した頂上に、V5という登山道を整備する。そして、Claude Codeというガイドと共に、誰もがその頂上からの景色を楽しめるようにする。

### あなたの次の一歩

もしあなたが：
- DDDに挫折した経験があるなら → V5の段階的アプローチを試してみてください
- DDDを実践中なら → V5の価値駆動で、設計に明確な指針を加えてください
- DDDを知らないなら → V5から始めて、自然にDDDの世界に入ってください

DDDの理想は、決して間違っていません。ただ、そこに至る道のりが、もっと歩きやすくなっただけです。

次章から始まる第II部では、V5の各フェーズを詳細に解説します。Phase 0-1でしっかりとした基礎を作り、Phase 2-3で価値とケイパビリティを設計し、Phase 4-7で実装に落とし込む。

理論は十分です。さあ、実践の時間です。

DDDの巨人の肩に乗って、より遠くの地平を見に行きましょう。