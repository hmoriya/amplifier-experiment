# 第3章　Parasol哲学とマインドセット ― 設計思想の深層へ

## はじめに：正しい設計から価値ある設計へ

ある優秀なエンジニアが、完璧なマイクロサービスアーキテクチャを設計しました。

DDDの教科書通りのBounded Context、美しいイベント駆動設計、最新のKubernetesクラスタ。技術的には申し分ありません。

でも、リリース後3ヶ月で、そのシステムは使われなくなりました。

なぜでしょうか？

答えは簡単です。そのシステムは「技術的に正しい」けれど、「価値を生まない」設計だったのです。ユーザーが本当に必要としていたのは、高度な機能ではなく、シンプルで素早い問題解決でした。

Parasol V5の哲学は、この「正しさ」と「価値」のギャップを埋めることから始まります。

## なぜ哲学が重要なのか

第2章で、V5の8つのフェーズを建築に例えて説明しました。でも、同じ設計図を渡しても、建築家によって全く異なる建物ができあがります。

その違いを生むのは何でしょうか？

それは「設計思想」です。どんな価値観で判断し、何を大切にし、どうバランスを取るか。この思想こそが、優れた設計と平凡な設計を分けるのです。

本章では、Parasol V5の核となる4つの設計思想を深く掘り下げます：

1. **価値中心設計** ― すべての判断を価値から始める
2. **構造的必然性** ― 恣意的な設計を排除する
3. **バランスの芸術** ― 理想と現実を調和させる
4. **公理的設計** ― 科学的根拠に基づく設計品質保証

これらは単なる「考え方」ではありません。日々の設計判断を導く、実践的な「判断基準」です。

## 価値中心設計：すべての始まり

### 「なぜ」から始める革命

従来の開発では、こんな会話がよくあります：

「ユーザー管理機能を作りたいんですが」
「分かりました。どんな機能が必要ですか？」
「登録、ログイン、パスワード変更、あと権限管理も...」

一見、普通の会話です。でも、最も重要な質問が抜けています。

「**なぜ**ユーザー管理が必要なのですか？」

V5の価値中心設計では、この「なぜ」こそが全ての出発点です。

### 「価値」の正しい理解 ― Vision/MissionとParasol VLの違い

ここで重要な区別をしておきましょう。「価値」という言葉は多義的で、混乱を招きやすい概念です。

多くの組織が掲げる「企業価値」と、Parasol V5で扱う「価値（VL）」は、全く異なる概念です。

**企業価値体系（Vision/Mission/Core Values）**

これらは「組織がどうあるべきか」を定義します：

- **Vision**：組織が目指す将来の姿（例：「世界中の人々の健康と幸せに貢献する」）
- **Mission**：組織の存在意義・社会的役割（例：「革新的な食品技術で社会課題を解決する」）
- **Core Values**：組織の行動原理・文化（例：「誠実」「挑戦」「品質へのこだわり」）

これらは**HOW（どのように振る舞うか）**を規定し、10年以上不変の「安定した錨」として機能します。

**Parasol価値（VL1→VL2→VL3）**

一方、V5で扱うVLは「顧客が何を受け取るか」を定義します：

- **VL1**：顧客が最終的に得る価値・変革
- **VL2**：VL1を構成する価値要素群
- **VL3**：測定・実装可能な具体的価値

これらは**WHAT（何を届けるか）**を規定し、顧客理解の深化により**進化（深化）**していきます。

**なぜこの区別が重要か**

```
Vision: 「世界中の人々の健康に貢献する」
            ↓ これは組織の志（HOW）
            ↓ 直接的にAPIやDBは設計できない

Parasol VL3: 「糖質30%オフビール」「機能性表示食品」
            ↓ これは顧客への提供物（WHAT）
            ↓ VL3 → VMS → VS → CL → BC → UseCase → API/DB
            ↓ 完全にトレース可能で、実装に落とし込める
```

Core Valuesの「誠実さ」からAPIは設計できませんが、VL3の「糖質30%オフ製品のパーソナライズ提案」からは設計できます。

Phase 1-2では、組織のVision/Mission/Core Valuesを**文脈として尊重**しつつ、Parasol VLを**顧客に届ける価値**として別途定義します。この明確な区別が、価値中心設計を成功させる鍵です。

### 価値の深掘り ― 表面から本質へ

実際の例で見てみましょう。あるECサイトでの会話です：

**表面的な要求**：
「商品レビュー機能を追加したい」

**第1層の深掘り**：
Q: なぜレビュー機能が必要ですか？
A: 競合サイトにもあるし、顧客から要望があるので。

**第2層の深掘り**：
Q: 顧客は本当は何を求めているのですか？
A: 商品を買う前に、他の人の評価を知りたいんです。

**第3層の深掘り**：
Q: それによって何が改善されますか？
A: 購買の不安が減って、返品率が下がるはずです。

**価値の核心に到達**：
「購買判断の不確実性を減らし、顧客満足度を向上させつつ返品コストを削減する」

この深掘りのプロセスで、「レビュー機能の実装」から「購買体験の改善」へと視点が変わりました。これが価値中心設計の本質です。

### 価値の可視化と定量化

発見した価値を、具体的に可視化します：

**価値ストリーム：購買判断支援**

| 状態 | 指標 | 値 |
|------|------|-----|
| 現状 | 返品率 | 15% |
| 現状 | 返品理由の60% | "思っていたのと違った" |
| 現状 | カスタマーサポート工数 | 月40時間 |
| 現状 | 顧客満足度 | 3.2/5.0 |
| 目標 | 返品率 | 10%以下 |
| 目標 | 返品理由 | 改善 |
| 目標 | サポート工数 | 月20時間 |
| 目標 | 顧客満足度 | 4.0/5.0 |

**価値メトリクス**

- ビジネス価値
  - 返品処理コスト削減：年間500万円
  - サポートコスト削減：年間200万円
- 顧客価値
  - 購買満足度向上
  - 購買決定時間の短縮

数字にすることで、「なんとなく良さそう」から「明確な投資対効果」が見えてきます。

### 価値トレーサビリティ ― 純度を保つ仕組み

建築で例えると、「採光を重視した明るい家」というコンセプトが、いつの間にか「窓の小さい要塞」になってしまうことがあります。なぜこんなことが起きるのでしょうか？

それは、設計の各段階で、最初の価値（明るい家）を見失うからです。

V5の価値トレーサビリティは、この「価値の変質」を防ぎます：

```
価値トレーサビリティの階層構造
================================

  [価値ストリーム]        ← 最上位：ビジネス価値
       購買判断支援
           │
           ▼
    [ケイパビリティ]      ← 能力の定義
    商品評価情報管理
           │
           ▼
  [Bounded Context]      ← ドメイン境界
  レビュー管理コンテキスト
           │
           ▼
      [Service]          ← 技術実装
    レビューサービス
           │
           ▼
        [API]            ← インターフェース
    POST /reviews
    GET /products/{id}/reviews

  ・・・・・・・・・・・・・・・・・・・
  :  価値の純度を保つ             :
  :  （各層で「なぜ必要か」を検証） :
  ・・・・・・・・・・・・・・・・・・・
```

各レベルで「なぜこれが必要か」を明確にし、最初の価値（購買判断支援）から逸脱していないかを常にチェックします。

## 構造的必然性：想像を排除する

### 恣意的な設計の罠

こんなコードを見たことはありませんか？

```python
class UserService:
    def get_user_profile(self, user_id):
        user = self.user_repo.find(user_id)
        orders = self.order_repo.find_by_user(user_id)
        reviews = self.review_repo.find_by_user(user_id)
        recommendations = self.recommendation_service.get_for_user(user_id)
        notifications = self.notification_service.get_unread(user_id)
        
        return {
            'user': user,
            'orders': orders,
            'reviews': reviews,
            'recommendations': recommendations,
            'notifications': notifications
        }
```

なぜUserServiceが注文、レビュー、レコメンデーション、通知まで知っているのでしょうか？

「画面にまとめて表示するから」

これが恣意的な設計です。表示の都合でサービスの境界を決めてしまっています。

### 構造的必然性とは何か

構造的必然性のある設計は、「なぜその境界なのか」に明確な理由があります：

```python
class UserProfileViewService:
    """
    ユーザープロフィール画面の表示に必要な情報を集約する
    画面固有のサービスであることを明示
    """
    def __init__(self, user_service, order_service, review_service, ...):
        # 各ドメインサービスに問い合わせる
        self.user_service = user_service
        self.order_service = order_service
        # ...
    
    def get_profile_view_data(self, user_id):
        # 画面表示のための集約であることが明確
        # 各サービスは自身の責任範囲のみを扱う
```

この構造は以下の理由で必然的です：
- プロフィール画面という「表示の関心事」を分離
- 各ドメインサービスの独立性を保持
- 画面変更が他のサービスに影響しない

### 必然性を見つける3つの問い

設計の必然性を確認するために、3つの問いを使います：

#### 1. この境界を変えたらどうなるか？

例：注文管理と在庫管理の境界

```
境界A：注文サービスが在庫も管理
→ 問題：在庫は倉庫や調達など、注文以外からも影響を受ける
→ 結論：境界として不適切

境界B：注文と在庫を分離
→ 利点：それぞれの関心事に集中できる
→ 結論：より自然な境界
```

#### 2. この構造でなければ実現できないか？

例：リアルタイム在庫表示

```
構造A：定期的なバッチ更新
→ 問題：「在庫あり」表示なのに売り切れる

構造B：イベント駆動更新
→ 必然性：リアルタイム性の要求から必然的に導かれる
```

#### 3. ビジネスがこう言うだろうか？

例：顧客サポートシステムの設計

```
技術的な表現：
「チケット管理サービス」「SLA監視サービス」

ビジネスの表現：
「顧客問題解決」「顧客満足度向上」

→ 後者の方が本質的で必然的
```

### コンウェイの法則を味方にする

「システムの構造は、それを作る組織の構造を反映する」

これを逆手に取ります。組織構造から、必然的なシステム境界が見えてきます。

**実例：ある小売企業の組織とシステム**

**組織構造**

| 部門 | 責任 | KPI |
|------|------|-----|
| 商品部 | 商品の仕入れと管理 | 商品回転率、粗利率 |
| 店舗運営部 | 店舗の売上最大化 | 店舗売上、在庫効率 |
| EC事業部 | オンライン販売 | サイト売上、コンバージョン率 |

**必然的なシステム境界**

| システム | オーナー | 責任範囲 |
|----------|----------|----------|
| 商品管理システム | 商品部 | マスタ管理、仕入れ |
| 店舗システム | 店舗運営部 | POS、在庫管理 |
| ECシステム | EC事業部 | サイト、受注管理 |

組織の責任境界は、ビジネスが長年かけて最適化してきた「必然的な境界」です。これに逆らうシステムは、運用で必ず問題を起こします。

## バランスの芸術：理想と現実の調和

### エレガンスの誘惑と実用性の要求

技術者なら誰もが、美しいコードに憧れます。

```python
# エレガントを追求したコード
class Repository(Generic[T]):
    def find(self, specification: Specification[T]) -> List[T]:
        return self._apply_specification(specification)

class AndSpecification(Specification[T]):
    def __init__(self, *specs: Specification[T]):
        self.specs = specs
    
    def is_satisfied_by(self, candidate: T) -> bool:
        return all(spec.is_satisfied_by(candidate) for spec in self.specs)

# 実用的なコード
class CustomerRepository:
    def find_active_premium_customers(self) -> List[Customer]:
        return self.db.query(
            "SELECT * FROM customers WHERE status = 'active' AND tier = 'premium'"
        )
```

どちらが良いでしょうか？

答えは「場合による」です。でも、多くの場合、実用的なコードの方が価値を生みます。なぜなら：

- チームの誰もが理解できる
- デバッグが簡単
- パフォーマンスが予測しやすい
- 変更の影響が明確

### バランスを取る4つの軸

#### 1. 抽象度のバランス

```
高抽象度 ←→ 具象的
Generic    Specific
柔軟       単純明快
```

**判断基準**：
- 変更頻度が高い → より抽象的に
- チームの技術レベル → 理解できる範囲で
- 3回同じパターン → 抽象化を検討

#### 2. 時間軸のバランス

```
今すぐの価値 ←→ 将来の価値
即効性          持続性
ROI明確         ROI不確実
```

**実践例**：技術的負債への対応

**時間軸別の価値対応**

| 時間軸 | 対応項目 | タイミング |
|--------|----------|------------|
| 即時価値 | 致命的バグ修正 | 即座に対応 |
| 即時価値 | 顧客要望機能 | 1-2週間で実装 |
| 短期価値 | パフォーマンス改善 | 3ヶ月以内 |
| 短期価値 | UI改善 | 次のリリースで |
| 長期価値 | アーキテクチャ刷新 | 年次計画 |
| 長期価値 | 技術スタック更新 | 段階的移行 |

#### 3. ステークホルダー間のバランス

あるAPI設計での議論：

**エンジニア**：「RESTfulに、リソース指向で設計したい」
**フロントエンド**：「画面に必要なデータを1回で取得したい」
**運用**：「監視しやすく、トラブルシューティングが簡単に」

**バランスの取れた解決策**：
**バランスの取れたAPI設計**

> **基本はRESTfulに**
> `GET /api/customers/{id}`
>
> **画面用には専用エンドポイント**
> `GET /api/views/customer-profile/{id}`
> （内部で複数のリソースを集約）

**運用のために**
- 詳細なログ出力
- メトリクス収集
- トレーシングID付与

#### 4. 品質特性のバランス

すべてを100点にはできません：

```
パフォーマンス ←→ 可読性
セキュリティ  ←→ 使いやすさ
柔軟性      ←→ シンプルさ
```

**優先順位の決め方**：
1. 価値に直結するものを最優先
2. 回復困難なものを次に（セキュリティなど）
3. 後から改善可能なものは許容

### 継続的価値創造の実践

システムは生き物です。リリースして終わりではありません。

**価値の減衰曲線**：

```
価値
↑
│     リリース時の価値
│    ╱╲
│   ╱  ╲___
│  ╱        ╲___  ← 保守されないシステム
│ ╱             ╲___
│╱    継続的改善 → ═══════  ← 価値を保つ
└────────────────────→ 時間
```

**価値を保つ3つの活動**：

1. **定期的な価値の再評価**
   - このシステムはまだ価値を生んでいるか？
   - 新しい価値を追加できないか？

2. **負債の計画的返済**
   - 価値創造を妨げる負債を優先
   - 小さく頻繁に返済

3. **新技術の選択的採用**
   - 流行ではなく価値で判断
   - 段階的な検証と導入

## 公理的設計：科学的な設計品質保証

### なぜ科学的根拠が必要なのか

「良い設計」とは何でしょうか？美しい？シンプル？保守しやすい？

これらは主観的な評価であり、チームや個人によって解釈が異なります。結果として、設計レビューが「好みの議論」に終始することがあります。

V5では、MIT（マサチューセッツ工科大学）のNam P. Suh教授が提唱した**Axiomatic Design（公理的設計）**を採用し、設計品質を科学的に評価する基準を提供します。

### Axiomatic Designの2つの公理

#### 公理1：独立公理（Independence Axiom）

> **「機能要件（FR）の独立性を維持せよ」**

建築で例えると、「窓の大きさを変えても、屋根の構造に影響しない」という設計です。

```
良い設計（Uncoupled）:
  FR1（採光） → DP1（窓サイズ）
  FR2（断熱） → DP2（断熱材厚さ）
  ※ それぞれ独立して調整可能

悪い設計（Coupled）:
  FR1（採光） → DP1（開口部） ← FR2（断熱）
  ※ 採光を増やすと断熱が悪化する
```

**V5での適用**：
- 各Bounded Context（BC）が独立した責任を持つ
- 1つのBCの変更が他のBCに波及しない
- サービス間はイベント駆動で疎結合に

#### 公理2：情報公理（Information Axiom）

> **「設計の情報量を最小化せよ」**

これは「シンプルにしろ」という曖昧な指示ではありません。**設計要素の数を必要最小限に抑える**という具体的な基準です。

```
情報量の例:
  VL階層深度 ≤ 3（VL1 → VL2 → VL3）
  CL階層深度 ≤ 3（CL1 → CL2 → CL3）
  VS数: 5-8個
  BC数/CL3数 比率: 0.8-1.2

過剰な情報（複雑すぎる）:
  VL階層深度 = 5
  VS数 = 15
  → 管理困難、全体把握不能
```

### Design Matrix：設計品質の可視化

独立公理を視覚的に評価するのが**Design Matrix（設計マトリクス）**です。

**評価の観点**：

| Matrix形状 | 意味 | 評価 |
|-----------|------|------|
| **Uncoupled**（対角行列） | 各FRに1つのDPが対応 | ✅ 理想的 |
| **Decoupled**（三角行列） | 順序付きで対応 | ⚠️ 許容範囲 |
| **Coupled**（非対角行列） | 相互依存あり | ❌ 要改善 |

**V5での例**：

```
CL3 → BC マッピング

        | 商品BC | 注文BC | 在庫BC |
商品管理 |   ✓   |        |        | → Uncoupled
注文処理 |        |   ✓   |   ✓   | → Decoupled（在庫確認必要）
在庫管理 |        |        |   ✓   | → Uncoupled

評価: Decoupled（許容範囲）
改善: 在庫確認をイベント駆動にすればUncoupledに近づく
```

### ADとV5の統合

Axiomatic Designは、V5の他の哲学を科学的に裏付けます：

| V5の哲学 | AD原則 | 関係 |
|---------|--------|------|
| 価値中心設計 | FR-DP対応 | 価値（FR）と実装（DP）の1:1対応 |
| 構造的必然性 | 独立公理 | 境界は独立性から導かれる |
| バランスの芸術 | 情報公理 | 複雑さの定量的判断基準 |

### 実践演習：AD評価

**状況**：
あるECサイトで、以下の設計が提案されました。

```
提案設計:
  OrderService が以下を管理:
    - 注文受付
    - 在庫確認
    - 決済処理
    - 配送手配
```

**課題**：
この設計をAD観点で評価し、改善案を提案してください。

**模範解答**：

**AD評価**：
- 独立公理違反：4つの機能が1つのサービスに結合（Coupled）
- 情報公理違反：1サービスの責任が過大

**改善案**：
```
Uncoupled設計:
  OrderService    → 注文受付
  InventoryService → 在庫確認
  PaymentService   → 決済処理
  ShippingService  → 配送手配

連携方式:
  Order作成 → InventoryReserved Event
            → PaymentCompleted Event
            → ShipmentScheduled Event
```

この改善により、各サービスが独立して変更・デプロイ可能になります。

## 哲学を実践に落とし込む

### 設計レビューでの活用

実際のレビューでの会話例：

**レビュアー**：「このマイクロサービス分割の根拠は？」

**設計者**：「注文と在庫を分離しました」

**レビュアー**：「なぜその境界？」（構造的必然性の確認）

**設計者**：「注文は顧客との約束、在庫は物理的な商品管理。責任が異なるので」

**レビュアー**：「それぞれが生む価値は？」（価値中心設計の確認）

**設計者**：
- 注文：顧客との約束を確実に履行（信頼性向上）
- 在庫：適正在庫による機会損失削減（収益性向上）

**レビュアー**：「統合の複雑さとのバランスは？」（バランスの確認）

**設計者**：「イベント駆動で疎結合に。複雑さは増すが、それぞれの価値最大化には必要」

このような対話を通じて、哲学に基づいた設計判断ができているかを確認します。

### 日常での小さな判断

哲学は、大きな設計だけでなく、日々の小さな判断にも適用されます：

**例：エラーメッセージの設計**

```python
# 技術視点のメッセージ
raise ValueError("Invalid parameter: user_id must be positive integer")

# 価値視点のメッセージ
raise ValueError(
    "ユーザーIDが正しくありません。"
    "もう一度ログインしてお試しください。"
    "問題が続く場合は、お問い合わせください。"
)
```

ユーザーにとっての価値（問題を解決して先に進める）を考えると、自然と後者になります。

### チームへの浸透

哲学を一人で抱えていても意味がありません。チーム全体で共有して初めて力を発揮します。

**段階的な浸透方法**：

1. **用語の共有から始める**
   - 「価値」「必然性」「バランス」を日常語に
   - 具体例を交えて説明

2. **小さな成功体験を作る**
   - 1つの機能で価値中心設計を実践
   - 効果を測定し、共有

3. **レビューで問いかける**
   - 「この設計の価値は？」
   - 「なぜこの境界？」
   - 徐々に皆が自問するように

4. **失敗からの学び**
   - 恣意的な設計の問題を振り返る
   - 次はどうすべきかを議論

## 実践演習：哲学を体得する

### 演習1：価値の発見

**状況**：
「ユーザー登録時のメール認証を追加したい」という要望

**課題**：
この要望の裏にある真の価値を発見してください。

**ヒント**：
- なぜメール認証が必要？
- 誰にとっての価値？
- 定量化できる指標は？

**模範解答**：
**価値の深掘り**

| 層 | 内容 |
|----|------|
| 表面的要望 | メール認証機能 |
| 第1層 | なりすまし防止 |
| 第2層 | 不正アカウントによる被害防止 |
| 第3層 | サービスの信頼性向上 |

**真の価値**

- ビジネス価値
  - 不正利用による損失削減：月額100万円
  - カスタマーサポートコスト削減：月20時間
  - 決済手数料の削減：3%
- 顧客価値
  - 安心してサービスを利用できる
  - 本物のユーザーとやり取りできる

### 演習2：構造的必然性の判断

**状況**：
ECサイトで商品検索機能を設計中

**選択肢**：
A. 商品サービスに検索機能を追加
B. 検索専用サービスを作成
C. 検索はフロントエンドで実装

**課題**：
最も構造的必然性のある選択とその理由を説明してください。

**模範解答**：
B. 検索専用サービスが最も必然的

理由：
- 検索は「問い合わせ」、商品管理は「状態管理」で責任が異なる
- 検索には特殊な技術（全文検索、ファセット等）が必要
- スケーラビリティ特性が異なる（検索は読み取り負荷が高い）
- 検索インデックスの更新は非同期で良い

### 演習3：バランスの判断

**状況**：
決済処理の実装で、以下の要求が競合：
- 開発チーム：シンプルな同期処理で実装したい
- ビジネス：取りこぼしゼロで確実に処理したい
- カスタマー：即座に結果を知りたい

**課題**：
これらのバランスを取る設計を提案してください。

**模範解答**：
**解決パターン：同期見せかけ + 非同期確実処理**

**処理フロー**

| ステップ | 処理内容 | 詳細 |
|----------|----------|------|
| 1. 同期的な仮受付 | 基本検証のみ | "受け付けました"をすぐ返す。顧客の期待に応える |
| 2. 非同期の本処理 | キューイングで確実性担保 | リトライ機能。ビジネスの要求を満たす |
| 3. 結果通知 | メール/プッシュ通知 | 画面上でのステータス更新 |

**バランス評価**

| 観点 | 評価 | 理由 |
|------|------|------|
| 顧客体験 | ◎ | 即座にフィードバック |
| 確実性 | ◎ | キューイングで保証 |
| 実装複雑度 | △ | 許容範囲の複雑さ |

## まとめ：哲学から行動へ

### 本章で学んだこと

1. **価値中心設計**
   - すべての判断は価値から始める
   - 深掘りして本質的な価値を発見する
   - 価値の純度をトレーサビリティで保つ

2. **構造的必然性**
   - 恣意的な設計を排除する
   - 「なぜこの構造か」に答えを持つ
   - ビジネスと組織から自然な境界を見つける

3. **バランスの芸術**
   - エレガンスと実用性の調和
   - 時間軸での価値配分
   - ステークホルダー間の利害調整

4. **公理的設計（Axiomatic Design）**
   - 独立公理：機能要件の独立性を維持する
   - 情報公理：設計の複雑さを最小化する
   - Design Matrixで設計品質を可視化・評価する

### 哲学を血肉にする

哲学は、読んで理解するものではありません。実践して体得するものです。

明日からできること：

1. **次の設計で「なぜ」を5回問う**
2. **境界を引くときに必然性を説明する**
3. **トレードオフを明示的に議論する**

最初は意識的に行う必要がありますが、やがて自然な思考パターンになります。そうなった時、あなたの設計は確実に一段階上のレベルに達しているでしょう。

### 次章への展望

哲学を理解したところで、次は具体的な実践です。第4章では、V5とDDD（ドメイン駆動設計）の関係を探ります。DDDの優れた概念を、V5の価値中心哲学でどのように昇華させるか。具体的なパターンとテクニックを学んでいきます。

理想の家を建てるには、哲学だけでなく、具体的な工法も必要です。その工法を、次章で身につけましょう。

準備はいいですか？

価値ある設計の世界へ、さらに深く潜っていきましょう。