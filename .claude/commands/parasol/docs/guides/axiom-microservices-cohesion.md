# 設計公理・マイクロサービス・凝集度の関係

**3つの概念が同じ原則を異なる角度から語っている**

---

## 概念の対応表

| Axiomatic Design | マイクロサービス | OOP/コンポーネント設計 |
|------------------|-----------------|---------------------|
| **独立公理** | 疎結合（Loose Coupling） | 低結合度（Low Coupling） |
| **情報公理** | 単一責任・境界明確化 | 高凝集度（High Cohesion） |

---

## 関係図

```
┌─────────────────────────────────────────────────────────────────────────┐
│                        良い設計の原則                                    │
└─────────────────────────────────────────────────────────────────────────┘
                              │
        ┌─────────────────────┴─────────────────────┐
        │                                           │
        ▼                                           ▼
┌───────────────────┐                     ┌───────────────────┐
│    独立公理        │                     │    情報公理        │
│ Independence Axiom │                     │ Information Axiom │
│                   │                     │                   │
│ 「機能間の独立性」  │                     │ 「複雑さの最小化」  │
└─────────┬─────────┘                     └─────────┬─────────┘
          │                                         │
          ▼                                         ▼
┌───────────────────┐                     ┌───────────────────┐
│   低結合度         │                     │   高凝集度         │
│  Low Coupling     │                     │  High Cohesion    │
│                   │                     │                   │
│ 「モジュール間の   │                     │ 「モジュール内の   │
│  依存を最小化」    │                     │  関連性を最大化」  │
└─────────┬─────────┘                     └─────────┬─────────┘
          │                                         │
          └──────────────┬──────────────────────────┘
                         │
                         ▼
          ┌───────────────────────────┐
          │   マイクロサービス原則     │
          │                           │
          │ ・独立デプロイ可能         │
          │ ・ビジネス境界で分割       │
          │ ・単一責任                │
          │ ・API契約による疎結合      │
          └───────────────────────────┘
```

---

## 1. 独立公理 ↔ 低結合度 ↔ 疎結合

### 同じことを違う言葉で言っている

| 観点 | 表現 | 意味 |
|------|------|------|
| Axiomatic Design | 独立公理 | FR(機能要件)が独立して変更可能 |
| OOP設計原則 | 低結合度 | クラス間の依存を最小化 |
| マイクロサービス | 疎結合 | サービス間の依存を最小化 |
| DDD | Bounded Context | コンテキスト間の境界を明確化 |

### 違反するとどうなるか

```
【独立公理違反 = 高結合度 = 密結合】

サービスA ←──→ サービスB ←──→ サービスC
    ↑              ↑              ↑
    └──────────────┴──────────────┘
           全部が繋がっている

結果:
❌ Aを変更 → B, Cも変更が必要
❌ Aの障害 → B, Cも停止
❌ Aのテスト → B, Cも必要
❌ Aのデプロイ → B, Cも同時デプロイ
```

### 遵守するとどうなるか

```
【独立公理遵守 = 低結合度 = 疎結合】

サービスA        サービスB        サービスC
    │                │                │
    └──→ API ←───────┴──→ API ←───────┘
         契約のみで接続

結果:
✅ Aを変更 → A単独で対応
✅ Aの障害 → B, Cは継続
✅ Aのテスト → A単独でOK
✅ Aのデプロイ → A単独でOK
```

---

## 2. 情報公理 ↔ 高凝集度 ↔ 単一責任

### 同じことを違う言葉で言っている

| 観点 | 表現 | 意味 |
|------|------|------|
| Axiomatic Design | 情報公理 | 設計の複雑さを最小化 |
| OOP設計原則 | 高凝集度 | 関連する機能を1箇所に集約 |
| SOLID | 単一責任原則(SRP) | 1クラス=1責任 |
| マイクロサービス | ビジネス境界 | 1サービス=1ビジネス機能 |
| DDD | Aggregate | 関連エンティティをまとめる |

### 違反するとどうなるか

```
【情報公理違反 = 低凝集度 = 責任過多】

┌─────────────────────────────────────┐
│           GodService               │
│                                    │
│  ・ユーザー管理                     │
│  ・商品管理                         │
│  ・注文処理                         │
│  ・決済処理                         │
│  ・通知送信                         │
│  ・レポート生成                     │
│  ・... 何でもやる                   │
└─────────────────────────────────────┘

結果:
❌ 理解に時間がかかる
❌ どこを修正すればいいか不明
❌ テストが複雑
❌ チーム分担が困難
```

### 遵守するとどうなるか

```
【情報公理遵守 = 高凝集度 = 単一責任】

┌──────────┐ ┌──────────┐ ┌──────────┐
│ユーザー   │ │商品      │ │注文      │
│サービス   │ │サービス   │ │サービス   │
│          │ │          │ │          │
│・登録    │ │・登録    │ │・作成    │
│・認証    │ │・検索    │ │・更新    │
│・更新    │ │・更新    │ │・キャンセル│
└──────────┘ └──────────┘ └──────────┘

結果:
✅ すぐ理解できる
✅ 修正箇所が明確
✅ テストが簡単
✅ チーム分担が容易
```

---

## 3. 凝集度の7段階

凝集度には強さのレベルがあります（上が良い、下が悪い）：

```
強い（良い）
  ▲
  │  ┌─────────────────────────────────────────────────────┐
  │  │ 機能的凝集（Functional）                            │
  │  │ → 単一の明確な機能を実行                            │
  │  │ 例: calculateTax(), validateEmail()                │
  │  │ AD: 情報公理を完全に満たす ✅                        │
  │  └─────────────────────────────────────────────────────┘
  │  ┌─────────────────────────────────────────────────────┐
  │  │ 逐次的凝集（Sequential）                            │
  │  │ → 前の出力が次の入力になる処理の連鎖                 │
  │  │ 例: readFile() → parseData() → validateData()      │
  │  │ AD: 情報公理を概ね満たす ✅                          │
  │  └─────────────────────────────────────────────────────┘
  │  ┌─────────────────────────────────────────────────────┐
  │  │ 通信的凝集（Communicational）                       │
  │  │ → 同じデータを操作する処理の集まり                   │
  │  │ 例: UserService(create, update, delete on User)    │
  │  │ AD: 情報公理を満たす ✅                              │
  │  └─────────────────────────────────────────────────────┘
  │  ┌─────────────────────────────────────────────────────┐
  │  │ 手続き的凝集（Procedural）                          │
  │  │ → 順番に実行される処理（データ共有なし）             │
  │  │ 例: initSystem(), loadConfig(), startServer()      │
  │  │ AD: 情報公理に注意が必要 △                          │
  │  └─────────────────────────────────────────────────────┘
  │  ┌─────────────────────────────────────────────────────┐
  │  │ 時間的凝集（Temporal）※技術的タイミング             │
  │  │ → 同じ技術的タイミングで実行される処理               │
  │  │ 例: startupTasks(), shutdownTasks()                │
  │  │ AD: 情報公理違反の兆候 ⚠️                           │
  │  │ ※ビジネス時間的凝集とは異なる（後述）               │
  │  └─────────────────────────────────────────────────────┘
  │  ┌─────────────────────────────────────────────────────┐
  │  │ 論理的凝集（Logical）                               │
  │  │ → 論理的に似ているが機能が異なる                     │
  │  │ 例: handleAllInputs(type) ← typeで分岐             │
  │  │ AD: 情報公理違反 ❌                                  │
  │  └─────────────────────────────────────────────────────┘
  │  ┌─────────────────────────────────────────────────────┐
  │  │ 偶発的凝集（Coincidental）                          │
  │  │ → 関連のない処理の寄せ集め                          │
  │  │ 例: Utilities, Helpers, Misc                       │
  │  │ AD: 情報公理に完全違反 ❌❌                          │
  │  └─────────────────────────────────────────────────────┘
  ▼
弱い（悪い）
```

---

## 4. 技術的時間 vs ビジネス的時間：凝集度の再評価

### 従来の凝集度理論の限界

従来のOOP凝集度理論では「時間的凝集」を弱い凝集度として扱う。しかし、これは**技術的タイミング**のみを想定している。

```
┌─────────────────────────────────────────────────────────────────┐
│  従来のOOP「時間的凝集」          vs   Parasol「バリューステージ」 │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  ❌ 技術的タイミング                 ✅ ビジネス的タイミング      │
│                                                                 │
│  initializeDatabase()              VS1: 認知形成                │
│  loadConfiguration()               VS2: 理解促進                │
│  startServer()                     VS3: 初期実践                │
│                                                                 │
│  → 「起動時に実行」という            → 「顧客ジャーニーの段階」   │
│    技術的理由だけで集約               というビジネス理由で分離    │
│                                                                 │
│  ビジネス意味: なし                 ビジネス意味: あり           │
│  変更理由: 技術都合                 変更理由: ビジネス都合        │
└─────────────────────────────────────────────────────────────────┘
```

### ビジネス時間的凝集（Business Temporal Cohesion）= WHEN軸

Parasol V5では、**顧客ジャーニーの時間軸（WHEN）**に基づく分離を採用。これは従来の「時間的凝集」とは本質的に異なる。

**WHEN = いつ価値を届けるか**: バリューステージは顧客ジャーニー上の時間軸を表現し、ビジネス変更の自然な境界となる。

```
【ビジネス時間的凝集の価値】= WHEN軸による分離

顧客ジャーニー = ビジネス価値の流れ（WHEN: いつ価値を届けるか）

  認知 → 理解 → 検討 → 購入 → 利用 → 継続
   ↓      ↓      ↓      ↓      ↓      ↓
  VS1    VS2    VS3    VS4    VS5    VS6
 (WHEN1) (WHEN2) (WHEN3) (WHEN4) (WHEN5) (WHEN6)

  各ステージ = 独立した価値提供単位（WHEN軸での分割）
  各ステージ内 = 高凝集なケイパビリティ（WHAT軸での分割）
```

### なぜビジネス時間軸での分離が有効か

#### 1. 変更の理由が明確

```
【従来のドメイン分割】
商品BC、注文BC、顧客BC...
  ↓
変更理由: 「商品の仕様が変わった」「注文フローが変わった」
  ↓
問題: ビジネス変更が複数BCに波及することが多い

【Parasolのステージ分割】
認知ステージ、理解ステージ、購入ステージ...
  ↓
変更理由: 「認知の仕方を変えたい」「購入体験を改善したい」
  ↓
利点: ビジネス変更がステージ内に閉じることが多い
```

#### 2. 独立公理との整合性

```
バリューステージ間の関係

VS1(認知) ──→ VS2(理解) ──→ VS3(実践)
    │            │            │
    ▼            ▼            ▼
┌──────┐    ┌──────┐    ┌──────┐
│ CL1  │    │ CL1  │    │ CL1  │  ← 各ステージ内で
│ CL2  │    │ CL2  │    │ CL2  │    ケイパビリティが独立
│ CL3  │    │ CL3  │    │ CL3  │
└──────┘    └──────┘    └──────┘

ステージ間: 順序依存（Decoupled）← 許容される
ステージ内: 独立（Uncoupled）← 理想的
```

#### 3. 情報公理との整合性

```
情報公理: 「複雑さを最小化せよ」

時間軸で分離することで:
・各ステージの責任が明確
・理解すべき範囲が限定される
・新人が「この段階だけ理解すればOK」

= 認知的複雑さの最小化 ✅
```

### 凝集度の拡張提案

従来の7段階に「ビジネス時間的凝集」を追加：

```
強い（良い）
  ▲
  │  機能的凝集（Functional）
  │  逐次的凝集（Sequential）
  │  通信的凝集（Communicational）
  │
  │  ┏━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┓
  │  ┃ 【NEW】ビジネス時間的凝集（Business Temporal）= WHEN ┃
  │  ┃                                                     ┃
  │  ┃ 顧客ジャーニーや価値提供の時間軸（WHEN）に基づく凝集┃
  │  ┃ 例: バリューステージ、購買ファネル段階              ┃
  │  ┃                                                     ┃
  │  ┃ 従来の「時間的凝集」とは本質的に異なる              ┃
  │  ┃ → ビジネス的意味があるため高凝集度 ✅               ┃
  │  ┃ → 情報公理を満たす（認知的複雑さを低減）            ┃
  │  ┃ → WHAT/HOW/WHENの3軸モデルで設計を立体化            ┃
  │  ┗━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┛
  │
  │  手続き的凝集（Procedural）
  │  時間的凝集（Temporal）← 技術的タイミングのみ ⚠️
  │  論理的凝集（Logical）
  │  偶発的凝集（Coincidental）
  ▼
弱い（悪い）
```

### 判定フローチャート

```
時間軸での分離を検討している
          │
          ▼
    ┌─────────────┐
    │ その時間軸は │
    │ ビジネス的か？│
    └──────┬──────┘
           │
     ┌─────┴─────┐
     │           │
     ▼           ▼
   YES          NO
     │           │
     ▼           ▼
┌─────────┐  ┌─────────┐
│ビジネス  │  │技術的   │
│時間的凝集│  │時間的凝集│
│ (WHEN)  │  │         │
│    ✅   │  │   ⚠️   │
└─────────┘  └─────────┘
     │           │
     ▼           ▼
 例:          例:
 ・顧客ジャーニー（WHEN）・起動時処理
 ・購買ファネル段階      ・シャットダウン
 ・ライフサイクル        ・バッチタイミング
```

---

## 5. マイクロサービスへの適用

### Design Matrixでサービス境界を評価

```
機能要件(FR)         サービス(DP)
                  UserSvc  OrderSvc  PaymentSvc
ユーザー登録      [  X        0          0     ]
注文作成          [  0        X          0     ]
決済処理          [  0        0          X     ]

→ Uncoupled設計 = 独立公理を満たす ✅
→ 各サービスが高凝集 = 情報公理を満たす ✅
```

### 悪いマイクロサービス設計

```
                  UserSvc  OrderSvc  PaymentSvc
ユーザー登録      [  X        X          0     ]  ← OrderSvcも関与？
注文作成          [  X        X          X     ]  ← 全部関与？
決済処理          [  0        X          X     ]

→ Coupled設計 = 独立公理違反 ❌
→ 責任が分散 = 情報公理違反 ❌

これは「分散モノリス」と呼ばれる最悪のパターン
```

---

## 6. Parasol V5での統合

### 3つの概念を統合した設計プロセス

```
┌─────────────────────────────────────────────────────────────────┐
│                    Parasol V5 設計フロー                         │
└─────────────────────────────────────────────────────────────────┘

Phase 3: 問題領域（WHAT）
┌─────────────────────────────────────────────────────────────────┐
│  CL3: 業務オペレーション                                         │
│                                                                 │
│  チェック:                                                       │
│  ・各CL3は独立しているか？ → 独立公理                            │
│  ・各CL3は単一責任か？ → 情報公理                                │
│  ・CL3数は最小限か？ → 情報公理                                  │
└─────────────────────────────────────────────────────────────────┘
                              │
                              ▼ DDDマッピング
Phase 4-5: 解決領域（HOW）
┌─────────────────────────────────────────────────────────────────┐
│  BC / マイクロサービス設計                                       │
│                                                                 │
│  チェック:                                                       │
│  ・BC間は疎結合か？ → 独立公理 → 低結合度                        │
│  ・BC内は高凝集か？ → 情報公理 → 高凝集度                        │
│  ・Design MatrixがUncoupledか？ → 独立公理                      │
└─────────────────────────────────────────────────────────────────┘
                              │
                              ▼
Phase 6: 実装
┌─────────────────────────────────────────────────────────────────┐
│  Service / Component実装                                        │
│                                                                 │
│  チェック:                                                       │
│  ・循環依存がないか？ → 独立公理                                 │
│  ・各Serviceが機能的凝集か？ → 情報公理                          │
│  ・Aggregate数が最小限か？ → 情報公理                            │
└─────────────────────────────────────────────────────────────────┘
```

---

## 7. 実践的なチェックリスト

### 設計レビュー時

```
□ 独立公理チェック（= 低結合度チェック）
  □ このコンポーネントを変更したとき、他に影響するか？
  □ このサービスを単独でデプロイできるか？
  □ このモジュールを単独でテストできるか？
  □ 循環依存がないか？

□ 情報公理チェック（= 高凝集度チェック）
  □ このコンポーネントの責任は1つか？
  □ このクラスの全メソッドは同じデータを操作するか？
  □ このサービス名で内容が想像できるか？
  □ 不要な機能が混在していないか？
```

### 凝集度の簡易判定

```
Q: このクラス/サービスの責任を一文で説明できるか？

✅ 「ユーザーの認証を行う」 → 機能的凝集（良い）
✅ 「注文データを管理する」 → 通信的凝集（良い）
✅ 「認知段階の価値を提供する」 → ビジネス時間的凝集（良い）
⚠️ 「起動時の初期化を行う」 → 技術的時間的凝集（注意）
❌ 「いろいろな便利機能」 → 偶発的凝集（悪い）
```

---

## まとめ

### 3つの概念は同じ原則の異なる表現

```
┌─────────────────────────────────────────────────────────────────┐
│                                                                 │
│   Axiomatic Design    =    OOP原則     =   マイクロサービス      │
│                                                                 │
│   独立公理            =    低結合度    =   疎結合               │
│   （機能間の独立）         （依存最小化）   （サービス間独立）     │
│                                                                 │
│   情報公理            =    高凝集度    =   単一責任/境界明確化   │
│   （複雑さ最小化）         （関連集約）     （ビジネス境界）       │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘

覚え方:
・独立公理 → 「外との関係を切る」 → 低結合度
・情報公理 → 「中を整理する」 → 高凝集度
```

### 良い設計の公式

```
良い設計 = 高凝集度 × 低結合度
        = 情報公理遵守 × 独立公理遵守
        = 単一責任 × 疎結合
```

### Parasol V5の貢献：凝集度理論の拡張

```
┌─────────────────────────────────────────────────────────────────┐
│  従来の凝集度理論                                                │
│  → 技術的視点（OOP/コンポーネント）に偏っていた                  │
│  → 「時間的凝集」を一律に弱い凝集度として扱っていた              │
├─────────────────────────────────────────────────────────────────┤
│  Parasolによる拡張                                               │
│  → 「ビジネス時間的凝集」という新カテゴリを提案                  │
│  → 顧客ジャーニー/価値ステージによる分離は高凝集度               │
│  → 技術的時間 vs ビジネス的時間 の区別を明確化                   │
├─────────────────────────────────────────────────────────────────┤
│  実践的示唆                                                      │
│  → バリューステージでの分離は設計公理を満たす                    │
│  → DDDのBounded Contextに時間軸の視点を追加                     │
│  → ビジネス変更がステージ内に閉じやすくなる                      │
└─────────────────────────────────────────────────────────────────┘
```

---

## 参考文献

- Nam P. Suh, "The Principles of Design" (Oxford University Press, 2001)
- Larry Constantine & Edward Yourdon, "Structured Design" (1979) - 凝集度・結合度の原典
- Sam Newman, "Building Microservices" (O'Reilly, 2021)
- Eric Evans, "Domain-Driven Design" (Addison-Wesley, 2003)
